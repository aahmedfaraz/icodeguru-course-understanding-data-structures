# -*- coding: utf-8 -*-
"""Queue.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZTugASDNQCU781PSoveyL6kIhYmhfg0w

# **Implementation Queue Data Structure Using Array**üèãÔ∏è‚Äç‚ôÄÔ∏è

## **Queue Implementation with procedural style: (without OOP concept)** ‚ô¶Ô∏è

The current implementation of Enqueue(Q, N, F, R, t) is written in a **procedural style**. In this approach:

Q, N, F, R, and t are all explicit parameters passed to the function. Q is the list that represents your queue, N is its maximum size, F is the front pointer, R is the rear pointer, and t is the item you want to add.
The function modifies Q, F, and R and then returns their new states. The management of these variables is external to the function itself.
"""

def Enqueue(Q, N, F, R, t):
    if (R == N - 1):
        print("Queue Overflow")
    else:
        if (R == -1):
            F = 0
            R = 0
        else:
            R += 1
        Q[R] = t
    return Q, F, R

def Dequeue(Q, F, R):
    if (F == -1 and R == -1):
        print("Queue Underflow")
        return None, F, R
    else:
        val = Q[F]
        if (F == R):
            F = -1
            R = -1
        else:
            F += 1
        return val, F, R

def GetFront(Q, F):
    if (F == -1):     #(or) if len(self.Q) == 0;
        print("Queue is empty")
        return None   #None is for safety for not throwing an error.
    else:
        return Q[F]   #(or) return self.Q[0]

def GetRear(Q, R):
    if (R == -1):
        print("Queue is empty")
        return None
    else:
        return Q[R]    #(or) return self.Q[-1]


# Example Usage:
N = 5 # Size of the queue
Q = [0] * N # Initialize queue with zeros
F = -1 # Front pointer
R = -1 # Rear pointer

print("Initial Queue:".ljust(20), Q, "F:", F, "R:", R)

Q, F, R = Enqueue(Q, N, F, R, 10)
print("After Enqueue(10):".ljust(20), Q, "F:", F, "R:", R)

Q, F, R = Enqueue(Q, N, F, R, 20)
print("After Enqueue(20):".ljust(20), Q, "F:", F, "R:", R)

Q, F, R = Enqueue(Q, N, F, R, 30)
print("After Enqueue(30):".ljust(20), Q, "F:", F, "R:", R)

Q, F, R = Enqueue(Q, N, F, R, 40)
print("After Enqueue:".ljust(20), Q, "F:", F, "R:", R)

Q, F, R = Enqueue(Q, N, F, R, 50)
print("After Enqueue:".ljust(20), Q, "F:", F, "R:", R)

front_value = GetFront(Q, F)
print("Front value:".ljust(20), front_value)

rear_value = GetRear(Q, R)
print("Rear value:".ljust(20), rear_value)


# val, F, R = Dequeue(Q, F, R)
# print("Dequeued value:", val, "Queue:", Q, "F:", F, "R:", R)

# front_value = GetFront(Q, F)
# print("Front value:".ljust(20), front_value)

# Q, F, R = Enqueue(Q, N, F, R, 30)
# print("After Enqueue(30):", Q, "F:", F, "R:", R)




# val, F, R = Dequeue(Q, F, R)
# print("Dequeued value:", val, "Queue:", Q, "F:", F, "R:", R)

val, F, R = Dequeue(Q, F, R)
print("Dequeued value:", val, "Queue:", Q, "F:", F, "R:", R)

# val, F, R = Dequeue(Q, F, R)
# print("Dequeued value:", val, "Queue:", Q, "F:", F, "R:", R)

"""## **Queue Implementation using OOP** üí°"""

class Queue:
    def __init__(self, size):
        self.N = size # Maximum size of the queue
        self.Q = [0] * self.N # Initialize queue with zeros
        self.F = -1 # Front pointer
        self.R = -1 # Rear pointer

    def enqueue(self, item):
        if (self.R == self.N - 1):
            print("Queue Overflow")
        else:
            if (self.R == -1): # If queue is empty
                self.F = 0
                self.R = 0
            else:
                self.R += 1
            self.Q[self.R] = item
            print(f"Enqueue {item}")
        # print(f"{'After Enqueue(' + str(item) + '):'.ljust(20)} Q: {self.Q}, F: {self.F}, R: {self.R}")

    def dequeue(self):
        if (self.F == -1 and self.R == -1):
            print("Queue Underflow")
            return None
        else:
            val = self.Q[self.F]
            if (self.F == self.R): # Last element in queue
                self.F = -1
                self.R = -1
            else:
                self.F += 1

            print(f"Dequeue {val}")
            # print(f"{'After Dequeue:'.ljust(20)} Q: {self.Q}, F: {self.F}, R: {self.R}")
            return val

    def get_front(self):
        if (self.F == -1):
            print("Queue is empty")
            return None
        else:
            return self.Q[self.F]

    def get_rear(self):
        if (self.R == -1):
            print("Queue is empty")
            return None
        else:
            return self.Q[self.R]

# Example Usage:
N = 5 # Size of the queue
my_queue = Queue(N)

print("Initial Queue State:")
print(f"{'Current State'.ljust(20)} Q: {my_queue.Q}, F: {my_queue.F}, R: {my_queue.R}")

my_queue.enqueue(10)
my_queue.enqueue(20)

front_value = my_queue.get_front()
print(f"{'Front value:'.ljust(20)} {front_value}")

rear_value = my_queue.get_rear()
print(f"{'Rear value:'.ljust(20)} {rear_value}")

dequeued_val = my_queue.dequeue()
print(f"{'Dequeued value:'.ljust(20)} {dequeued_val}")

my_queue.enqueue(30)
my_queue.enqueue(40)
my_queue.enqueue(50)
my_queue.enqueue(60) # This should cause an overflow

# val, F, R = Dequeue(Q, F, R)
# print("Dequeued value:", val, "Queue:", Q, "F:", F, "R:", R)

# Q, F, R = Enqueue(Q, N, F, R, 30)
# print("After Enqueue(30):", Q, "F:", F, "R:", R)

# val, F, R = Dequeue(Q, F, R)
# print("Dequeued value:", val, "Queue:", Q, "F:", F, "R:", R)

# val, F, R = Dequeue(Q, F, R)
# print("Dequeued value:", val, "Queue:", Q, "F:", F, "R:", R)

# val, F, R = Dequeue(Q, F, R)
# print("Dequeued value:", val, "Queue:", Q, "F:", F, "R:", R)

# OOP RELATED

# dequeued_val = my_queue.dequeue()
# print(f"{'Dequeued value:'.ljust(20)} {dequeued_val}")
# dequeued_val = my_queue.dequeue()
# print(f"{'Dequeued value:'.ljust(20)} {dequeued_val}")
# dequeued_val = my_queue.dequeue()
# print(f"{'Dequeued value:'.ljust(20)} {dequeued_val}")
# dequeued_val = my_queue.dequeue()
# print(f"{'Dequeued value:'.ljust(20)} {dequeued_val}") # This should empty the queue
# dequeued_val = my_queue.dequeue()
# print(f"{'Dequeued value:'.ljust(20)} {dequeued_val}") # This should cause an underflow

"""For example, if you have the string `"Hello"` and you apply `.ljust(10)` to it, the result will be `"Hello     "` (with 5 spaces added to the right) because the total width is 10 characters and "Hello" has 5 characters."""

my_string = "Hello"
justified_string = my_string.ljust(10)
print(f"Original string: '{my_string}'")
print(f"Justified string: '{justified_string}'")
print(f"Length of justified string: {len(justified_string)}")

# In your code, it was used like this:
label = "Front value:"
print(label.ljust(20), 10)

# This means 'Front value:' (12 characters) is padded with 8 spaces
# to make its total length 20 characters before printing it,
# creating a neatly aligned output.