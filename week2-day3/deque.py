# -*- coding: utf-8 -*-
"""Deque.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d10lSjtusuznII6X_xSV_owfwyDJLzy9

# â­•ðŸ’«**IMPLEMENTING DEQUE USING CIRCULAR ARRAY:**
"""

class Deque:
    def __init__(self, size):
        self.size = size
        self.arr = [None] * size
        self.front = -1
        self.rear = -1

    def is_empty(self):
        return self.front == -1

    def is_full(self):
        return (self.rear + 1) % self.size == self.front

    def insert_front(self, data):
        if self.is_full():
            raise IndexError("Deque is full")

        if self.is_empty():
            self.front = 0
            self.rear = 0
        else:
            self.front = (self.front - 1 + self.size) % self.size

        self.arr[self.front] = data

    def insert_rear(self, data):
        if self.is_full():
            raise IndexError("Deque is full")

        if self.is_empty():
            self.front = 0
            self.rear = 0
        else:
            self.rear = (self.rear + 1) % self.size

        self.arr[self.rear] = data

    def delete_front(self):
        if self.is_empty():
            raise IndexError("Deque is empty")

        if self.front == self.rear:
            self.front = -1
            self.rear = -1
        else:
            self.front = (self.front + 1) % self.size

    def delete_rear(self):
        if self.is_empty():
            raise IndexError("Deque is empty")

        if self.front == self.rear:
            self.front = -1
            self.rear = -1
        else:
            self.rear = (self.rear - 1 + self.size) % self.size

    def get_front(self):
        if self.is_empty():
            raise IndexError("Deque is empty")
            return
        if self.front == self.rear:
            return self.arr[self.front]
        else:
          return self.arr[self.front]     #whereever the front pointer is (pointing the value)return it.

    def get_rear(self):
        if self.is_empty():
            raise IndexError("Deque is empty")
            return
        if self.front == self.rear:
            return self.arr[self.rear]
        else:
          return self.arr[self.rear]


size = 5
arr = Deque(size)
Front = -1
Rear = -1

initial_deque = [0] * size
print(initial_deque)

#insert front
arr.insert_front(10)

print(arr.arr)

#insert rear
arr.insert_rear(60)
print(arr.arr)

#delete front
arr.delete_front()
print(f"deleted_front".ljust(20), arr.arr)

#delete rear
arr.delete_rear()
print(f"deleted_rear".ljust(20), arr.arr, "Front Pointer:", arr.front, "Rear Pointer:", arr.rear)

F = arr.insert_front(10)
R = arr.insert_rear(20)
print(f"Recent Deque is:", arr.arr, "Front Pointer:", arr.front, "Rear Pointer:", arr.rear)
F = arr.insert_front(30)
print(f"Recent Deque is:", arr.arr, "Front Pointer:", arr.front, "Rear Pointer:", arr.rear)
F = arr.insert_front(40)
print(f"Recent Deque is:", arr.arr, "Front Pointer:", arr.front, "Rear Pointer:", arr.rear)
F = arr.insert_rear(50)
print(f"Recent Deque is:", arr.arr, "Front Pointer:", arr.front, "Rear Pointer:", arr.rear)

"""## **NOTE:** the element not visually deleted but logically deleted.
When Deque.delete_front() is called, it logically removes the element at the front of the Deque. In this implementation, the element (which was 10) is not actually removed from the underlying array; instead, the front pointer is simply moved to the next element. So, while 10 is no longer considered part of the Deque, it still visually appears in the array. The next element, 60, is now at the front of the Deque.


## **NOW, THE SAFETY PRECAUTION:**
Yes, absolutely! Applying the Deque.is_empty() and Deque.is_full() conditions (as you've already done in your implementation) at the beginning of your insertion and deletion methods is indeed the best and most effective practice. This ensures that you handle edge cases correctly, prevent errors like trying to delete from an empty deque or insert into a full one, and maintain the integrity of your data structure.

"""